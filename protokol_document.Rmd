---
title: "REAN protokol"
author: "Martin Oharek"
date: "12 Ăşnora 2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Knihovny
Na zaÄŤĂˇtek naÄŤteme doporuÄŤenĂ© knihovny
```{r}
lbs <- c('car','MASS','tidyverse','ggplot2','ISLR','graphics','effects','leaps','psych',
         'lattice','lmtest','robustbase')

install.lib <- lbs[!lbs %in% installed.packages()]
for(libs in install.lib) install.packages(libs, dependences = TRUE)
sapply(lbs, require, character = TRUE)
```

# ZpracovĂˇnĂ­ dat, prĹŻzkumovĂˇ a grafickĂˇ ÄŤĂˇst

## OtĂˇzka ÄŤ.1: ZjistÄ›te, zdali data neobsahujĂ­ chybÄ›jĂ­cĂ­ hodnoty (NA), pokud ano tak rozhodnÄ›te zdali mĹŻĹľete pĹ™Ă­sluĹˇnĂˇ pozorovĂˇnĂ­ z dat odstranit.

Jako prvnĂ­ data naÄŤteme z pĹ™Ă­sluĹˇnĂ©ho souboru

```{r}
my_data <- read.table("auto-mpg-01rean.txt",header = TRUE)
my_data = as.data.frame(my_data)
```

Potom se na data podĂ­vĂˇme pĹ™es summary funkci
```{r}
summary(my_data)
```

VidĂ­me, Ĺľe se vyskytuje 6 NaNs v promÄ›nnĂ© horsepower a 9 NaNs v promÄ›nnĂ© mpg. OdstranÄ›nĂ­ pĹ™Ă­sluĹˇnĂ˝ch Ĺ™ĂˇdkĹŻ zĂˇvisĂ­ na plĂˇnovanĂ©m vyuĹľitĂ­ datasetu. Pokud budeme chtĂ­t regresovat mpg, pak jistÄ› budeme muset odstranit Ĺ™Ăˇdky s NaNy v mpg. Pokud budeme chtĂ­t regresovat navĂ­c pomocĂ­ horsepower, pak budeme muset odstranit i Ĺ™Ăˇdky s NaNy v horsepower. V naĹˇem pĹ™Ă­padÄ› je celkovÄ› 15 Ĺ™ĂˇdkĹŻ s Nany, coĹľ nenĂ­ vzhledem k celkovĂ©mu poÄŤtu 406 mnoho, navĂ­c budeme tĂ©mÄ›Ĺ™ ve vĹˇech pozdÄ›jĹˇĂ­ch ĂşlohĂˇch pracovat jak s mpg, tak horsepower dohromady, proto pro vÄ›tĹˇĂ­ pĹ™ehlednost budeme uvaĹľovat pouze data bez NaNĹŻ jiĹľ od zaÄŤĂˇtku pro vĹˇechny nĂˇsledujĂ­cĂ­ Ăşlohy.

```{r}
data_mpghp = my_data[!is.na(my_data$mpg) & !is.na(my_data$horsepower),]

```

## OtĂˇzka ÄŤ.2: KterĂ© promÄ›nnĂ© jsou kvantitativnĂ­ a kterĂ© kvalitativnĂ­? Jeli moĹľno nÄ›kterĂ© zaĹ™adit do obou skupin, pro kterou se rozhodnete? KterĂ© promÄ›nnĂ© budete brĂˇt jako faktorovĂ© a proÄŤ?

Za kvalitativnĂ­ promÄ›nnĂ© vÄ›tĹˇinou bereme kategorickĂ© promÄ›nnĂ©, kterĂ© nabĂ˝vajĂ­ diskrĂ©tnĂ­ch hodnot. KvantitativnĂ­ jsou naopak spojitĂ©, numerickĂ© promÄ›nnĂ©, kterĂ© popisujĂ­ ÄŤĂ­selnou velikost, mnoĹľstvĂ­,..

ZĹ™ejmÄ› kvantitativnĂ­ promÄ›nnĂ© v naĹˇem pĹ™Ă­padÄ› jsou mpg, displacement, horsepower, weight a acceleration. FaktorovĂ© jsou urÄŤitÄ› origin a car_name. Do obou skupin lze zaĹ™adit cylinders a model_year. Jestli danou promÄ›nnou brĂˇt jako faktorovou ÄŤi nikoliv zĂˇvisĂ­ na zkoumanĂ©m problĂ©mu a plĂˇnovanĂ©m vyuĹľitĂ­ vĂ˝slednĂ©ho modelu. NapĹ™. pokud budeme chtĂ­t pouĹľĂ­vat model i na automobily o jinĂ©m poÄŤtu vĂˇlcĹŻ neĹľ mĂˇme v datasetu, pak zvolĂ­me cylinders jako numerickou promÄ›nnou. Ale napĹ™. model_year bych urÄŤitÄ› nebral jako numerickou promÄ›nnou, zde nedĂˇvĂˇ pĹ™Ă­liĹˇ smysl do modelu dosazovat jinĂ© roky, neĹľ se kterĂ˝mi se setkĂˇme v datasetu, nebo napĹ™. dosazovat neceloÄŤĂ­selnĂ© hodnoty let. PĹ™edpoklĂˇdat, Ĺľe spotĹ™eba se bude mÄ›nit lineĂˇrnÄ› i v budoucnu ÄŤi v minulosti vzhledem k naĹˇim datĹŻm mi nepĹ™ijde sprĂˇvnĂ©.

MomentĂˇlnÄ› zvolĂ­m cylinders i model_year jako kategorickĂ© promÄ›nnĂ©.

```{r}
data_mpghp$origin = as.factor(data_mpghp$origin)
data_mpghp$cylinders = as.factor(data_mpghp$cylinders)
data_mpghp$model_year = as.factor(data_mpghp$model_year)


```

## OtĂˇzka ÄŤ.3: PromÄ›nnou mpg nahraÄŹte promÄ›nnou consumption, kde bude mĂ­sto poÄŤtu ujetĂ˝ch mil na galon paliva uvedena hodnota poÄŤet litrĹŻ na 100km. Jednotky promÄ›nnĂ© displacement pĹ™evÄ›ÄŹte z kubickĂ˝ch palcĹŻ na litry a weight z liber na kilogramy.

```{r}
data_mpghp$consumption = (100*3.785411)/(data_mpghp$mpg * 1.609344)
data_mpghp$displacement = data_mpghp$displacement*0.016387064
data_mpghp$weight = data_mpghp$weight*0.45359237

```

## OtĂˇzka ÄŤ.4: Vykreslete histogramy a odhady hustot consumption, displacement, acceleration, horsepower, weight, model_year. PromÄ›nnou consumption vykreslete pomocĂ­ scatterplotu spolu s ostatnĂ­mi promÄ›nnĂ˝mi - zĂˇvislost odezvy ("consumption") na vysvÄ›tlujĂ­cĂ­ch promÄ›nnĂ˝ch. ProloĹľte body jak lineĂˇrnĂ­m odhadem, tak vyhlazenou kĹ™ivkou lokĂˇlnĂ­ regrese, buÄŹ pomocĂ­ LOESS (locally estimated scatterplot smoothing) nebo LOWESS (locally weighted scatterplot smoothing)(lines(lowess(X,Y))). Co lze z tohoto obrĂˇzku pĹ™edpoklĂˇdat o zĂˇvislosti spotĹ™eby auta na dalĹˇĂ­ch promÄ›nnĂ˝ch. 

Jako prvnĂ­ vykreslĂ­me histogramy.

```{r}
data_mpghp$model_year = as.numeric(as.character(data_mpghp$model_year))# zmÄ›nĂ­me zpÄ›t na numerickou kvĹŻli histogramu

cols = c('consumption', 'displacement', 'acceleration', 'horsepower', 'weight', 'model_year')
par(mfrow = c(2, 3))
for (col in cols)
{
  hist(data_mpghp[,col],xlab = col,main = '')
}

```


NynĂ­ vykreslĂ­me odhady hustot.

```{r}

par(mfrow = c(2, 3))
for (col in cols)
{
  hist(data_mpghp[,col],xlab = col,freq=FALSE,main = '')
  lines(density(data_mpghp[,col]), col="red", lwd=1)
}
```


A naposledy scatterploty s kĹ™ivkou lokĂˇlnĂ­ regrese.

```{r}
par(mfrow = c(2, 3))
cols = c('displacement', 'acceleration', 'horsepower', 'weight', 'model_year')
for (col in cols)
{
  scatter.smooth(data_mpghp[,col],data_mpghp[,'consumption'],
                 xlab = col,ylab = 'consumption',main = '',lpars = list(col='blue',lwd=2))
  abline(lm(data_mpghp[,'consumption'] ~ data_mpghp[,col],data = data_mpghp),col = 'red', lwd = 2)  
}

```

Z obrĂˇzku vidĂ­me, Ĺľe se kĹ™ivky "pĹ™ibliĹľnÄ›" podobajĂ­, z toho lze usoudit, Ĺľe data jsou vhodnĂˇ modelovat pomocĂ­ lineĂˇrnĂ­ regrese. Pokud by se kĹ™ivky vĂ˝znamnÄ› liĹˇily, pak by uĹľ dopĹ™edu mohlo bĂ˝t jasnÄ›jĹˇĂ­, Ĺľe (jednoduchĂ˝) lineĂˇrnĂ­ model nebude pĹ™Ă­liĹˇ vhodnou volbou a stĂˇlo by za to vybrat jinĂ˝ (nelineĂˇrnĂ­) model.

DĂˇle si mĹŻĹľeme vĹˇimnout pomÄ›rnÄ› logickĂ˝ch trendĹŻ, kterĂ© nĂˇm ovÄ›Ĺ™ujĂ­, Ĺľe data jsou smysluplnĂˇ, napĹ™. mĹŻĹľeme vidÄ›t, Ĺľe se zvyĹˇujĂ­cĂ­ se vĂˇhou ÄŤi vĂ˝konem vozidla se zvyĹˇuje i spotĹ™eba, coĹľ souhlasĂ­ s jakousi empirickou a fyzikĂˇlnĂ­ znalostĂ­ problĂ©mu. TakĂ© se s pĹ™ibĂ˝vajĂ­cĂ­mi roky vÄ›tĹˇinou spotĹ™eba sniĹľovala. Zde by bylo zajĂ­mavĂ© si vykreslit (bude rozebrĂˇno v Ăşkolu ÄŤ.8) zĂˇvislost vĂ˝konu ÄŤi zrychlenĂ­ v zĂˇvislosti na model_year a ovÄ›Ĺ™it, Ĺľe deficit ve spotĹ™ebÄ› negativnÄ› neovlivnil tyto promÄ›nnĂ©.

## OtĂˇzka ÄŤ.5: Z promÄ›nnĂ© car_name vytvoĹ™te promÄ›nnou model podle prvnĂ­ho slova obsaĹľenĂ©ho v Ĺ™etÄ›zci. Pro promÄ›nnĂ© model_year, model, cylinders, origin a jejich vztah k odezvÄ› consumption vykreslete krabicovĂ© diagramy (boxploty). Je mezi uvedenĂ˝mi promÄ›nnĂ˝mi nÄ›kterĂˇ, pro kterou byste na zĂˇkladÄ› krabicovĂ˝ch diagramĹŻ navrhli slouÄŤit urÄŤitĂ© ĂşrovnÄ› dohromady? Je z tÄ›chto grafĹŻ vidÄ›t, Ĺľe nÄ›kterĂˇ auta majĂ­ jinou, neĹľ oÄŤekĂˇvanou spotĹ™ebu?

Ke splnÄ›nĂ­ Ăşlohy vyuĹľijeme balĂ­ÄŤek "stringr", kterĂ˝ nĂˇm usnadnĂ­ prĂˇci.
```{r}
library('stringr')
data_mpghp$producer = word(data_mpghp$car_name,1)
data_mpghp$model_year = factor(data_mpghp$model_year) # model_year pĹ™evedeme zpÄ›t na faktor
```

Na vykreslenĂ­ boxplotu vyuĹľijeme ggplot

```{r}
library(gplots)
library(ggplot2)
library(ggpubr)
cols = c('model_year','producer','cylinders','origin')
p1 <- ggplot(data_mpghp,aes(x=model_year,y=consumption, fill = model_year)) + 
    geom_boxplot(notch=FALSE,outlier.color = 'black') + scale_fill_discrete(name='year')
plot(p1)
p2 <- ggplot(data_mpghp,aes(x=producer,y=consumption, fill = producer)) + 
  geom_boxplot(notch=FALSE,outlier.color = 'black') + scale_fill_discrete(name='producer') +
  theme(axis.text.x=element_text(angle=75))
plot(p2)

p3 <- ggplot(data_mpghp,aes(x=cylinders,y=consumption,fill = cylinders)) + 
  geom_boxplot(notch=FALSE,outlier.color = 'black') + scale_fill_discrete(name='cylinders')
plot(p3)

p4 <- ggplot(data_mpghp,aes(x=origin,y=consumption,fill = origin)) + 
  geom_boxplot(notch=FALSE,outlier.color = 'black') + scale_x_discrete(labels=c("1" = "USA", "2" = "Evropa","3" = "Japonsko"))+
  scale_fill_discrete(name='origin',labels=c("1" = "USA", "2" = "Evropa","3" = "Japonsko"))
plot(p4)


```

Dle podobnosti stĹ™ednĂ­ch hodnot a mediĂˇnĹŻ by se da slouÄŤit model_year na mĂ©nÄ› faktorĹŻ. Daly by se slouÄŤit roky 70-73, 74-79, 80-82. OstatnĂ­ promÄ›nnĂ© bych nesluÄŤoval, jelikoĹľ rozdĂ­ly stĹ™ednĂ­ch hodnot a mediĂˇnĹŻ pro jednotlivĂ© faktory jsou pĹ™Ă­liĹˇ velkĂ©.

Jde vidÄ›t, Ĺľe auta se 3 vĂˇlci majĂ­vyšší spotĹ™ebu neĹľ auta se 4 a 5 vĂˇlci, coĹľ trochu poruĹˇuje trend, kterĂ˝ vidĂ­me u 4 az 8 vĂˇlcovĂ˝ch aut, kde zpravidla ÄŤĂ­m nižší poÄŤet vĂˇlcĹŻ, tĂ­m nižší spotĹ™eba. AvĹˇak to nemusĂ­ bĂ˝t nutnÄ› chyba, jelikoĹľ spotĹ™ebu ovlivĹujĂ­ i dalĹˇĂ­ nezĂˇvislĂ© promÄ›nnĂ©.


## OtĂˇzka ÄŤ.6: Pro kombinaci faktorizovanĂ˝ch promÄ›nnĂ˝ch cylinders a origin vykreslete spotĹ™ebu aut, aby bylo na obrĂˇzku vidÄ›t, jestli se liĹˇĂ­ spotĹ™eba u aut pochĂˇzejĂ­cĂ­ch z rĹŻznĂ˝ch kontinentĹŻ v zĂˇvislosti na poÄŤtu vĂˇlcĹŻ a naopak.


```{r}
p <- ggplot(data_mpghp,aes(y=consumption))+
  geom_point(aes(x = origin,colour=cylinders))+
  scale_x_discrete(labels=c("1" = "USA", "2" = "Evropa","3" = "Japonsko"))
print(p)
```


## OtĂˇzka ÄŤ.7: Pro auta vĂ˝robce Chrysler vykreslete zĂˇvislost spotĹ™eby na vĂˇze automobilu, kde jednotlivĂ© udĂˇlosti oznaÄŤĂ­te barvou podle poÄŤtu vĂˇlcĹŻ a velikosti bodĹŻ v grafu bude odpovĂ­dat objemu motoru. 

```{r}
data_chrysler = data_mpghp[data_mpghp[,'producer']=='chrysler',]
p <- ggplot(data_chrysler,aes(x=weight,y=consumption))+
  geom_point(aes(size = displacement, colour = cylinders))
print(p)
```

## OtĂˇzka ÄŤ.8: NavrhnÄ›te dalĹˇĂ­ zobrazenĂ­ datovĂ©ho souboru. ProveÄŹte ho a popiĹˇte jeho ĂşÄŤel.

UĹľ bylo zmĂ­nÄ›no v otĂˇzce ÄŤ.4, Ĺľe z grafĹŻ bylo vidÄ›t sniĹľovĂˇnĂ­ spotĹ™eby v prĹŻbÄ›hu let. Bylo by proto zajĂ­mavĂ© vykreslit jinĂ© promÄ›nnĂ©, napĹ™. vĂ˝kon, vĂˇhu ÄŤi zrychlenĂ­ a podĂ­vat se, jak se tyto veliÄŤiny mÄ›nily s pĹ™ibĂ˝vajĂ­cĂ­m ÄŤasem. PodĂ­vĂˇme se tak na to, jestli sniĹľovĂˇnĂ­ spotĹ™eby v dĹŻsledky lidskĂ©ho rozvoje nemÄ›lo negativnĂ­ vliv na ostatnĂ­ klĂ­ÄŤovĂ© parametry vozidla (jinak by takovĂ˝ vĂ˝voj byl ponÄ›kud kontraproduktivnĂ­, pokud samozĹ™ejmÄ› nebylo cĂ­lem pouze snĂ­Ĺľit spotĹ™ebu i pĹ™es fakt, Ĺľe zĂ­skĂˇme pomalejĹˇĂ­, mĂ©nÄ› schopnĂ© vozidlo). Tyto veliÄŤiny bychom mÄ›li vykreslovat pro jednotlivĂ© producery zvlĂˇĹˇĹĄ. ZkusĂ­me napĹ™. auta znaÄŤky chrysler.

```{r}
p1 <- ggplot(data_chrysler,aes(x=model_year,y=acceleration))+
  geom_point(aes(size = consumption))
print(p1)

```
```{r}
p2 <- ggplot(data_chrysler,aes(x=model_year,y=horsepower))+
  geom_point(aes(size = consumption))
print(p2)

```
```{r}
p3 <- ggplot(data_chrysler,aes(x=model_year,y=weight))+
  geom_point(aes(size = consumption))
print(p3)

```

VidĂ­me, Ĺľe spotĹ™eba aut se v prĹŻbÄ›hu let u tĂ©to znaÄŤky sniĹľovala a s nĂ­ vÄ›tĹˇinou i vĂ˝kon. Naopak zrychlenĂ­ se zvyĹˇovalo. Tohle souvisĂ­ s tĂ­m, Ĺľe byla tendence znaÄŤky sniĹľovat hmotnost a tĂ­m pĂˇdem i se snĂ­ĹľenĂ­m vĂ˝konu motoru zvÄ›tĹˇit zrychlenĂ­ auta.

## OtĂˇzka ÄŤ.9: Sestavte jednoduchĂ˝ regresnĂ­ model, kde vysvÄ›tlovanĂˇ promÄ›nnĂˇ bude spotĹ™eba automobilu. Na jeho zĂˇkladech zjistÄ›te, zdali spotĹ™eba automobilu zĂˇvisĂ­ na hmotnosti automobilu. Pokud ano, o kolik se zmÄ›nĂ­ spotĹ™eba automobilu pokud se hmotnost zvĂ˝ĹˇĂ­ o 1000kg?

PĹ™ipravĂ­me si jednoduchý model s interceptem. Model bez interceptu by v tomot případě nejspíše měl nějaký intuitivní smysl (auto vážící 0kg spotřebuje 0l paliva), nicméně v praxi nikdy nenarazíme na auto vážící 0kg Budeme tudíž uvažovat pouze model s interceptem. Co se tĂ˝kĂˇ zĂˇvislosti spotĹ™eby na hmotnosti, je z pĹ™edchozĂ­ch scatterplotĹŻ zĹ™ejmĂ©, Ĺľe spotĹ™eba na hmotnosti zĂˇvisĂ­. OvÄ›Ĺ™Ă­me si to i z hodnot t-statistik koeficientĹŻ z obou modelĹŻ.

```{r}
lm_intercept = lm(consumption ~ weight, data_mpghp)

```

PodĂ­vĂˇme se na summary funkce

```{r}
summary(lm_intercept)
```

Hodnota t-statistiky je extrĂ©mnÄ› malá, coĹľ jakousi zĂˇvislost spotĹ™eby na vĂˇze potvrzuje. Abychom to mohli Ĺ™Ă­ct s vÄ›tĹˇĂ­ jistotou, je potĹ™eba prvnĂ­ model validovat.
PĹ™i zmÄ›nÄ› vĂˇhy o 1000kg se v modelu s interceptem zmÄ›nĂ­ spotĹ™eba (po zaokrouhlenĂ­) o 8,9. 

## OtĂˇzka ÄŤ.10: DĂˇ se pĹ™edeĹˇlĂ˝ jednoduchĂ˝ regresnĂ­ model zlepĹˇit pomocĂ­ logaritmickĂ© transformace odezvy? Jak se potĂ© zmÄ›nĂ­ (navĂ˝ĹˇĂ­/poklesne) spotĹ™eba automobilu pĹ™i zmÄ›nÄ› hmotnosti o 1000kg? ZdĹŻvodnÄ›te, proÄŤ pĹ™Ă­padnĂ© transformace je pĹ™Ă­nosnĂˇ, nebo naopak nepĹ™Ă­nosnĂˇ.


Jako prvnĂ­ se vykreslĂ­me scatterplot bez i s log transformovanou spotĹ™ebou a podĂ­vĂˇme se, jestli dostaneme "hezÄŤĂ­" graf.

```{r}
par(mfrow = c(1,2))
plot(data_mpghp$weight,data_mpghp$consumption,xlab = 'weight',ylab='consumption')
plot(data_mpghp$weight,log(data_mpghp$consumption),xlab = 'weight',ylab='log(consumption)')

```

Z grafĹŻ nenĂ­ patrnĂ©, Ĺľe by log transformace mÄ›la vĂ©st k vyĹˇĹˇĂ­ pĹ™esnosti modelu. NastavĂ­me lineĂˇrnĂ­ model.


```{r}
lm_logcons = lm(log(consumption)~weight,data_mpghp)
```

podĂ­vĂˇme se na vĂ˝stup ze summary funkce pro tento model
```{r}
summary(lm_logcons)
```

V ÄŤem tahle transformace mohla pomoci je zajiĹˇtÄ›nĂ­ validace OLS poĹľadavkĹŻ, k ÄŤemuĹľ se ÄŤasto takovĂ© transformace v praxi vyuĹľĂ­vajĂ­. TĂ­mto se budeme zabĂ˝vat v pozdÄ›jĹˇĂ­ch otĂˇzkĂˇch. Interpretovatelnost se příliš nezhorší. Jen se v tomto případě už nemůžeme bavit o aditivním rozdílu, ale o multiplikativním rozdílu. v případě log transformace dostáváme pro podíl původních netransformovaných spotřeb při rozdílu hmotnosti o 1000kg vztah y1/y2 = e^(1000*alfa) , kde alfa je koeficient u hmotnosti.
Tedy při změně váhy se spotřeba zvýší
```{r}
exp(lm_logcons$coefficients['weight']*1000)
```
přibližně 2,15 krát proti původní hodnotě.

Z vykreslenĂ˝ch grafĹŻ se zdĂˇ, Ĺľe by mohla navĂ­c k log transformaci pomoci jeĹˇtÄ› nÄ›jakĂˇ mocninnĂˇ transformace, tĂ­m bychom mohli graf lĂ©pe "vyrovnat", pro zajĂ­mavost zkusĂ­me druhou mocninnu.
```{r}
lm_logcons_squared = lm((log(consumption))^2~weight,data_mpghp)
```

PodĂ­vĂˇme se na summary funkci.

```{r}
summary(lm_logcons_squared)
```
Validace modelu nechĂˇm na pozdÄ›ji. JeĹˇtÄ› si kĹ™ivky vykreslĂ­me spolu se scatterplotem.

```{r}
p <- ggplot(data_mpghp, aes(x=weight, y=consumption)) + geom_point() +
  geom_line(aes(x = weight, y = lm_intercept$fitted.values, col="red"),size=0.8)+
  geom_line(aes(x = weight, y = exp(sqrt(lm_logcons_squared$fitted.values)),col="green") ,size = 0.8)+
  geom_line(aes(x = weight, y = exp(lm_logcons$fitted.values),col="yellow"),size = 0.8)+
   scale_color_discrete(name = 'models',labels = c('lm_log_squared','lm_intercept','lm_log'))
plot(p)
```


## OtĂˇzka ÄŤ.11: VyzkouĹˇejte transformovat nezĂˇvislou promÄ›nnou hmotnost. VyzkouĹˇejte napĹ™. po ÄŤĂˇstech konstantnĂ­ transformaci a polynomiĂˇlnĂ­ transformace (kvadratickou a kubickou).

Jako prvnĂ­ provedeme po ÄŤĂˇstech konstantnĂ­ transformaci hmotnosti, intervaly zvolĂ­me po 100kg a v kaĹľdĂ©m intervalu bude hodnota zvolena jako stĹ™ednĂ­ hodnota pĹŻvodnĂ­ch hmotnostĂ­ spadajĂ­cĂ­ch do tohoto intervalu.

```{r}
breaks = seq(from = min(data_mpghp$weight), to = max(data_mpghp$weight)+100, by = 100)
data_mpghp$constant_weight2 = cut(data_mpghp$weight, breaks = breaks, include.lowest = TRUE, right = FALSE)
data_mpghp$constant_weight = replicate(length(data_mpghp$constant_weight2),0)
for (i in levels(factor(data_mpghp$constant_weight2)))
{
  temp = mean(data_mpghp[data_mpghp$constant_weight2 == i,'weight'])
  data_mpghp[data_mpghp$constant_weight2 == i,'constant_weight'] = temp
}
```

Ve sloupci constant_weight jsou nynĂ­ hodnoty po ÄŤĂˇstech konstantnĂ­ transformace.

VytvoĹ™Ă­me pĹ™Ă­sluĹˇnĂ© modely.
```{r}
lm_const = lm(consumption ~ constant_weight,data_mpghp)
lm_quadratic = lm(consumption ~ I(weight^2),data_mpghp)
lm_cubic = lm(consumption ~ I(weight^3),data_mpghp)
```
Modely si vypĂ­Ĺˇeme pomocĂ­ summary funkce.
```{r}
summary(lm_const)
summary(lm_quadratic)
summary(lm_cubic)
```


NynĂ­ si vykreslĂ­me scatterploty s proloĹľenĂ­m pĹ™Ă­sluĹˇnou kĹ™ivkou.

```{r}
p_const <- ggplot(data_mpghp, aes(x=constant_weight, y=consumption)) + geom_point()+
  geom_line(aes(x = constant_weight, y = lm_const$fitted.values ,colour = 'red'),size=0.8)


p_quadratic <- ggplot(data_mpghp, aes(x=weight^2, y=consumption)) + geom_point()+
  geom_line(aes(x = weight^2, y = lm_quadratic$fitted.values ,colour = 'red'),size=0.8)


p_cubic <- ggplot(data_mpghp, aes(x=weight^3, y=consumption)) + geom_point()+
  geom_line(aes(x = weight^3, y = lm_cubic$fitted.values ,colour = 'red'),size=0.8)
figure <- ggarrange(p_const, p_quadratic, p_cubic,
                    labels = c("p.č.konst.", "kvadratická", "kubická"),
                    ncol = 2, nrow = 2)
plot(figure)
```


## OtĂˇzka ÄŤ.12: Pro vĂˇmi vybranĂ˝ finĂˇlnĂ­ model ovÄ›Ĺ™te pĹ™edpoklady pro pouĹľitĂ­ OLS, diskutujte vĂ˝stup a model validujte pomocĂ­ pĹ™Ă­sluĹˇnĂ˝ch testĹŻ na rezidua a pomocĂ­ pĹ™Ă­sluĹˇnĂ˝ch obrĂˇzkĹŻ (QQplot, residua vs fitted, residua vs regressors atd.)

PotĹ™ebujeme ovÄ›Ĺ™it:
1. nezĂˇvilost a homoskedasticitu reziduĂ­, coĹľ mĹŻĹľeme ovÄ›Ĺ™it napĹ™. z residuals vs fitted plotu (nebo scale-location plot), homoskedasticitu mĹŻĹľeme jeĹˇtÄ› ovÄ›Ĺ™it napĹ™. pomocĂ­ breusch-paganova testu (bptest)
2. normalitu reziduĂ­ pomocĂ­ QQ plotu a napĹ™. sapirova testu

Jako prvnĂ­ ovÄ›Ĺ™Ă­me klasickĂ˝ model bez transformace. ZaÄŤneme normalitou. VykreslĂ­me QQplot.
```{r}
par(mfrow = c(1,2))
plot(lm_intercept,which=2)
```
Ty chvosty nevypadajĂ­ pĹ™Ă­liĹˇ dobĹ™e, podĂ­vĂˇme se na vĂ˝sledek shapirova testu, uvedeme i model bez interceptu.
```{r}
shapiro.test(residuals(lm_intercept))

```

ObÄ› p-hodnoty jsou kriticky nĂ­zkĂ©, tedy test na normalitu neproĹˇel. ZkusĂ­me model s log transformovanou spotĹ™ebou.

ZaÄŤneme normalitou.
```{r}
plot(lm_logcons,which=2)
```
To uĹľ vypadĂˇ o nÄ›co lĂ©pe.
```{r}
shapiro.test(residuals(lm_logcons))
```

ShapirĹŻv test normalitu reziduĂ­ nezamĂ­tĂˇ. PodĂ­vĂˇme se na homoskedasticitu reziduĂ­.
```{r}
plot(lm_logcons,which=1)
```
Residuals vs fitted plot vypadĂˇ hezky. PodĂ­vĂˇme se na bptest.
```{r}
bptest(lm_logcons)
  
```

Zde vyĹˇla p-hodnota nad 0.05, tedy homoskedasticitu nezamĂ­tĂˇme. Tento model na OLS poĹľadavky tedy proĹˇel.

ZkusĂ­m jeĹˇtÄ› model lm_logcons_squared.
```{r}
plot(lm_logcons_squared,which=2)
```
```{r}
shapiro.test(residuals(lm_logcons_squared))
```
Zde vyĹˇla p-hodnota dokonce o nÄ›co vyĹˇĹˇĂ­ neĹľ u lm_logcons.
```{r}
plot(lm_logcons_squared,which=1)
```
A residuals vs fitted plot vypadĂˇ taky o nÄ›co lĂ©pe neĹľ v pĹ™edchozĂ­m pĹ™Ă­padÄ›.
```{r}
bptest(lm_logcons_squared)
  
```
Homoskedasticita je zde daleko lepĹˇĂ­ neĹľ v pĹ™edchozĂ­m pĹ™Ă­padÄ›, coĹľ nĂˇm hezky potvrzuje i bptest.

PĹ™i porovnĂˇnĂ­ modelĹŻ log_cons a log_cons_squared se jevĂ­ jako lepĹˇĂ­ druhĂˇ varianta i vzhledem k R^2 statistice.



## OtĂˇzka ÄŤ.13: Vykreslete scatterplot skuteÄŤnĂ˝ch spotĹ™eb aut a hmotnostĂ­ a na zĂˇkladÄ› vybranĂ©ho modelu. ProloĹľte skrze data odhadnutou regresnĂ­ pĹ™Ă­mku a vykreslete 95% konfidenÄŤnĂ­ intervaly, jak pro predikovanĂ© hodnoty, tak pro regresnĂ­ pĹ™Ă­mku (tzv. Confidence a Prediction band). Porovnejte s vĂ˝sledkem z funkce plot(allEfects(model)).

Vybral jsem model lm_logcons_squared. PrvnĂ­ vykreslĂ­me obrĂˇzky pro transformovanou spotĹ™ebu.

```{r}

pred_transf = predict(lm_logcons_squared,data_mpghp,interval = 'prediction')
conf_transf = predict(lm_logcons_squared,data_mpghp,interval = 'confidence')

data <- cbind(data_mpghp, pred_transf)
conf_transf = data.frame(conf_transf)
conf_transf$weight = data_mpghp$weight

# vykreslĂ­me
p1 <- ggplot(data, aes(x=weight, y=(log(consumption))^2)) + geom_point()+
  geom_line(aes(y = lwr ,colour = 'red'),size=0.8) +
  geom_line(aes(y = upr ,colour = 'red'),size=0.8) +
  geom_line(data=conf_transf,aes(x=weight,y = lwr ,colour = 'blue'),size=0.8) +
  geom_line(data=conf_transf,aes(x=weight,y = upr ,colour = 'blue'),size=0.8)+
  scale_color_discrete(name = 'bands',labels = c('confident','prediction'))
plot(p1)
  
```


NynĂ­ vykreslĂ­me netransformovanou spotĹ™ebu a proloĹľĂ­me kĹ™ivkou.


```{r}

p <- ggplot(data, aes(x=weight, y=consumption)) + geom_point()+
  geom_line(aes(x=weight,y=exp(sqrt(lm_logcons_squared$fitted.values)), colour = "red"),size = 0.8) +
  scale_color_discrete(name = 'model',labels = c('lm_logcons_squared'))
  
plot(p)

```


NynĂ­ zkusĂ­me vykreslit vĂ˝stup z allEffects.

```{r}

library(effects)
plot(allEffects(lm_logcons_squared))

```


Plot vypadĂˇ stejnÄ› jako nĂˇĹˇ. Confident band souhlasĂ­.


## OtĂˇzka ÄŤ.14: PĹ™idejte k vysvÄ›tlujĂ­cĂ­m promÄ›nnĂ˝m i promÄ›nnou origin, navrhnÄ›te aditivnĂ­ lineĂˇrnĂ­ model, a ve scatterplotu vykreslete 3 skupiny rĹŻznĂ˝mi barvami a data proloĹľte odpovĂ­dajĂ­cĂ­mi regresnĂ­mi pĹ™Ă­mkami.

VyrobĂ­me aditivnĂ­ model.
```{r}

lm_weight_origin<-lm(consumption~weight+origin,data_mpghp)
summary(lm_weight_origin)

```


Data rozdÄ›lĂ­me podle origin a vykreslĂ­me i s regresnĂ­mi pĹ™Ă­mkami.
```{r}
data_split_origin  <- split(data_mpghp, data_mpghp$origin)
data_split_origin[['1']]$Fit <- predict(lm_weight_origin, data_split_origin[['1']])
data_split_origin[['2']]$Fit  <- predict(lm_weight_origin, data_split_origin[['2']])
data_split_origin[['3']]$Fit  <- predict(lm_weight_origin, data_split_origin[['3']])

p <- ggplot(data_mpghp, aes(x=weight, y=consumption, color = origin))+geom_point()+
  geom_line(data = data_split_origin[['1']], aes(x=weight,y=Fit), size = 0.8)+
  geom_line(data = data_split_origin[['2']], aes(x=weight,y=Fit), size = 0.8)+
  geom_line(data = data_split_origin[['3']], aes(x=weight,y=Fit), size = 0.8)
  
plot(p)

```

VidĂ­me, Ĺľe regresnĂ­ pĹ™Ă­mky z aditivnĂ­ho modelu pro jednotlivĂ© zemÄ› jsou velmi podobnĂ©. Jde vidÄ›t, Ĺľe origin v tomto modelu pĹ™Ă­liĹˇ spotĹ™ebu neovlivĹuje.

## OtĂˇzka ÄŤ.15: Porovnejte pomocĂ­ vhodnĂ©ho statistickĂ©ho testu shodnost stĹ™ednĂ­ch hodnot spotĹ™eby cen u automobilĹŻ pochĂˇzejĂ­cĂ­ch z rĹŻznĂ˝ch kontinentĹŻ a podle poÄŤtu vĂˇlcĹŻ (faktorizovanĂˇ promÄ›nnĂˇ). ZdĹŻvodnÄ›te zdali tyto statistickĂ© testy jsou vypovĂ­dajĂ­cĂ­ a zdali lze z nich urÄŤit dĹŻleĹľitost danĂ˝ch promÄ›nnĂ˝ch pro predikci ceny automobilu.

Jako statistickĂ˝ test pouĹľijeme rozĹˇĂ­Ĺ™enĂ­ t-testu, tzv. one-way anova test.
Je alternativou t-testu, pokud mĂˇme vĂ­ce neĹľ 2 faktory. Tento test pĹ™edpoklĂˇdĂˇ normalitu dat v kaĹľdĂ©m faktoru a stejnĂ© rozptyly napĹ™Ă­c faktory (mÄ›lo by se ovÄ›Ĺ™it).
Pokud bychom nesplnili tyto poĹľadavky, lze pouĹľĂ­t jako alternativu KruskalĹŻv test.


VykreslĂ­me obrĂˇzky zvlĂˇĹˇĹĄ pro origin a pro cylinders.
```{r}
library("ggpubr")
p1 <- ggline(data_mpghp, x = 'origin', y = 'consumption', 
            add = c("mean_se", "jitter"), 
            order = c("1", "2", "3"))


p2 <- ggline(data_mpghp, x = 'cylinders', y = 'consumption', 
            add = c("mean_se", "jitter"))

figure <- ggarrange(p1, p2,
                    ncol = 2, nrow = 2)
plot(figure)

```

Z obrĂˇzku vidĂ­me, Ĺľe stĹ™ednĂ­ hodnoty nabĂ˝vajĂ­ na prvnĂ­ pohled rĹŻznĂ˝ch hodnot mezi faktory. PodĂ­vĂˇme se na vĂ˝sledky testĹŻ.
```{r}
summary(aov(consumption~origin,data_mpghp))
kruskal.test(consumption~origin,data_mpghp)

summary(aov(consumption~cylinders,data_mpghp))
kruskal.test(consumption~cylinders,data_mpghp)

```


V obou pĹ™Ă­padech vidĂ­me velmi nĂ­zkou p-hodnotu, kterĂˇ znamenĂˇ, Ĺľe zamĂ­tĂˇme nulovou hypotĂ©zu, tedy rovnost stĹ™ednĂ­ch hodnot. KruskalĹŻv test to pro origin i cylinders potvrzuje.

Pokud by nastala situace, Ĺľe by se stĹ™ednĂ­ hodnoty consumption rovnali pro nÄ›jakou faktorovou promÄ›nnou pro kaĹľdĂ˝ faktor, pak si myslĂ­m, Ĺľe danĂˇ faktorovĂˇ promÄ›nnĂˇ nebude mĂ­t
pĹ™Ă­liĹˇ velkĂ˝ vliv na vysvÄ›tlovanou promÄ›nnou (zanedbatelnĂ˝ ÄŤi ĹľĂˇdnĂ˝ vliv), kvĹŻli rovnostem stĹ™ednĂ­ch hodnot se jednotlivĂ© hodnoty v rĹŻznĂ˝ch faktorech budou 'dost podobat' a tĂ­m pĂˇdem v podstatÄ› rĹŻznĂ© faktory nebudou mĂ­t vliv na zmÄ›nu spotĹ™eby.

MĹŻĹľeme tuto myĹˇlenku demonstrovat na pĹ™Ă­kladu. UmÄ›le vytvoĹ™Ă­me 3-faktorovou promÄ›nnou, kde se v kaĹľdĂ©m faktoru bude rovnat stĹ™ednĂ­ hodnota vysvÄ›tlovanĂ© veliÄŤiny (generovanĂˇ z normĂˇlnĂ­ho rozdÄ›lenĂ­). NĂˇslednÄ› udÄ›lĂˇme stejnĂ˝ experiment, jen s tĂ­m rozdĂ­lem, Ĺľe se stĹ™ednĂ­ hodnoty rovnat nebudou.

```{r}
x <- seq(-20, 20, by = .1)
x_1 <- rep(1,length(x))
y_1 <- rnorm(x,mean=0,sd=1)


x_2 <- rep(2,length(x))
y_2 <- rnorm(x,mean=0,sd=2)

x_3 <- rep(3,length(x))
y_3 <- rnorm(x,mean=0,sd=0.5)

df1=data.frame(explanatory = y_1,independent = x_1)
df2=data.frame(explanatory = y_2,independent = x_2)
df3=data.frame(explanatory = y_3,independent = x_3)

df = rbind(df1,df2,df3)
df$independent = factor(df$independent)

lm = lm(explanatory~independent,df)
summary(lm)

```

Ze summary funkce vidĂ­me, Ĺľe ĹľĂˇdnĂˇ z faktorĹŻ neovlivĹuje vysvÄ›tlovanou veliÄŤinu a tudĂ­Ĺľ je zbyteÄŤnĂ© regresovat podle tĂ©to promÄ›nnĂ© (obrovskĂ© p-hodnoty koeficientĹŻ).

NynĂ­ uvedeme pĹ™Ă­pad, kdy se stĹ™ednĂ­ hodnoty rovnat nebudou.

```{r}
x <- seq(-20, 20, by = .1)
x_1 <- rep(1,length(x))
y_1 <- rnorm(x,mean=0,sd=1)

x_2 <- rep(2,length(x))
y_2 <- rnorm(x,mean=1,sd=1)

x_3 <- rep(3,length(x))
y_3 <- rnorm(x,mean=0.5,sd=0.5)


df1=data.frame(explanatory = y_1,independent = x_1)
df2=data.frame(explanatory = y_2,independent = x_2)
df3=data.frame(explanatory = y_3,independent = x_3)

df = rbind(df1,df2,df3)
df$independent = factor(df$independent)

lm = lm(explanatory~independent,df)
summary(lm)

```

V tomto pĹ™Ă­padÄ› uĹľ je zĂˇvislost zĹ™ejmĂˇ (p-hodnoty jsou extrĂ©mnÄ› nĂ­zkĂ©).

## OtĂˇzka ÄŤ.16: Zkonstruujte lineĂˇrnĂ­ model popisujĂ­cĂ­ spotĹ™ebu automobilu s vyuĹľitĂ­m vĹˇech dostupnĂ˝ch promÄ›nnĂ˝ch, kde bude pĹ™Ă­tomna interakce nejvĂ˝Ĺˇe dvou promÄ›nnĂ˝ch. Na zĂˇkladÄ› kritĂ©riĂ­ jako jsou AIC, BIC, R^2, F, atd. vyberte nejvhodnÄ›jĹˇĂ­ model. Ten validujte a okomentujte jeho vĂ˝bÄ›r.

V modelu nebudeme uvaĹľovat vĹˇechny pomocnĂ© promÄ›nnĂ©, co jsme si v prĹŻbÄ›hu zpracovĂˇnĂ­ protokolu vytvoĹ™ili. DĂˇle nebudeme uvaĹľovat car_name, jelikoĹľ bychom dostali extrĂ©mnĂ­ poÄŤet faktorĹŻ a takĂ© promÄ›nnou producer kvĹŻli vysokĂ©mu poÄŤtu faktorĹŻ a takĂ© zĹ™ejmĂ© kolinearitÄ› s origin (mohli bychom slouÄŤit producery z jednĂ© zemÄ› do jednoho, viz obrĂˇzek).

```{r}
p <- ggplot(data_mpghp, aes(x=producer, y=consumption, color = origin))+geom_point()+theme(axis.text.x = element_text(angle = 75))
plot(p)

```

PromÄ›nnou cylinders v pĹ™Ă­padÄ› vĂ­cerozmÄ›rnĂ© regrese budeme uvaĹľovat jako numerickou promÄ›nnou, jednak kvĹŻli snĂ­ĹľenĂ­ poÄŤtu faktorĹŻ v modelu (origin dohromady s model_year uĹľ dajĂ­ 14 faktorĹŻ) a takĂ© kvĹŻli pĹ™esnÄ›jĹˇĂ­ detekci multikolinearity mezi numerickĂ˝mi promÄ›nnĂ˝mi.

NachystĂˇme tedy maximĂˇlnÄ› velikĂ˝ model s interakcemi.

```{r}
data_mpghp$cylinders = as.numeric(as.character(data_mpghp$cylinders))
lm_all  <- lm(consumption ~ (.-car_name-producer-mpg-constant_weight-constant_weight2)*(.-car_name-producer-mpg-constant_weight-constant_weight2), data = data_mpghp)
summary(lm_all)

```

Kolinearita v modelu je zĹ™ejmĂˇ. Vzhledem k nĂˇsledujĂ­cĂ­m otĂˇzkĂˇm jejĂ­ Ĺ™eĹˇenĂ­ odloĹľĂ­me na pozdÄ›ji a teÄŹ ji vynechĂˇme.
PouĹľijeme AIC i BIC hodnoty k urÄŤenĂ­ nejvhodnÄ›jĹˇĂ­ho modelu z lm_all. Pak vĂ˝slednĂ© modely z obou metod porovnĂˇme pomocĂ­ anova() a vybereme ten vhodnÄ›jĹˇĂ­.

Vypisovat celou proceduru by zabralo mnoho stran, tak zde vypisovĂˇnĂ­ outputu z funkce vynechĂˇm a uvedeme jen porovnĂˇnĂ­ a summary vĂ˝slednĂ©ho modelu.

```{r}
lm_temp_aic <- stepAIC(lm_all,direction='backward', trace=FALSE) # AIC
lm_temp_bic <- stepAIC(lm_all,direction='backward', k=log(nrow(data_mpghp)), trace=FALSE) # BIC

```

PorovnĂˇme oba modely pomocĂ­ anova()

```{r}
anova(lm_temp_bic,lm_temp_aic)

```

Z nĂ­zkĂ© hodnoty vychĂˇzĂ­, Ĺľe anova() preferuje model zĂ­skanĂ˝ metodou AIC. Budeme tedy pokraÄŤovat s lm_temp_aic. Detaily modelu vypĂ­Ĺˇeme pomocĂ­ summary funkce.
```{r}
summary(lm_temp_aic)
```

PokusĂ­me se nynĂ­ validovat OLS pĹ™edpoklady. ZaÄŤneme normalitou.
```{r}
plot(lm_temp_aic,which=2)

```
QQ plot nevypadĂˇ pĹ™Ă­liĹˇ dobĹ™e, je tam pĹ™Ă­liĹˇ velkĂ© odchĂ˝lenĂ­ chvostĹŻ. PodĂ­vĂˇme se na shapirĹŻv test.
```{r}
shapiro.test(residuals(lm_temp_aic))
```

p-hodnota je pĹ™Ă­liĹˇ nĂ­zkĂˇ, shapirĹŻv test normalitu zamĂ­tĂˇ. OLS poĹľdavaky tento model nesplĹuje. V dalĹˇĂ­ch otĂˇzkĂˇch budeme zkouĹˇet rĹŻznĂ© transformace z dĹŻvodu zlepĹˇenĂ­ normality. ProblĂ©my s normalitou mohou bĂ˝t takĂ© zpĹŻsobeny multikolinearitou v modelu, kterou budeme takĂ© teprve zkoumat.

## OtĂˇzka ÄŤ.17: Pro vybranĂ˝ model z pĹ™edchozĂ­ otĂˇzky vyzkouĹˇejte jak logaritmickou transformaci odezvy, tak Box-Coxovu transformaci pro zlepĹˇenĂ­ normality reziduĂ­. Vykreslete optimĂˇlnĂ­ log-vÄ›rohodnostnĂ­ profil u Box-Coxovy transformace a porovnejte navrĹľenou mocninou transformaci s logaritmickou. Pro kterĂ˝ model se rozhodnete a proÄŤ?

Jako prvnĂ­ provedeme logaritmickou transformaci.

```{r}
form = 'log(consumption) ~ cylinders + displacement + horsepower + weight + 
acceleration + model_year + origin + cylinders:horsepower + 
cylinders:model_year + displacement:horsepower + displacement:acceleration + 
displacement:model_year + displacement:origin + horsepower:weight + 
horsepower:model_year + weight:acceleration + weight:model_year + 
weight:origin + acceleration:model_year + acceleration:origin'

lm_final_log = lm(form,data_mpghp)
summary(lm_final_log)

```

ZkusĂ­me tento model validovat.

```{r}
par(mfrow = c(1,2))
plot(lm_final_log,which=1)
plot(lm_final_log,which=2)


```
QQ plot i residuals vs fitted vypadajĂ­ velmi hezky. PodĂ­vĂˇme se, co Ĺ™Ă­kĂˇ ShapirĹŻv test.

```{r}
shapiro.test(residuals(lm_final_log))
```

Ten normalitu nezamĂ­tĂˇ, takĹľe zde logaritmickĂˇ transformace pomohla k lepĹˇĂ­mi splnÄ›nĂ­ OLS poĹľadavkĹŻ.

ZkusĂ­me Box-Coxovu transformaci.
```{r}
library(MASS)
bc <- boxcox(lm_temp_aic)
lambda <- bc$x[which.max(bc$y)]

```


NastavĂ­me pĹ™Ă­sluĹˇnĂ˝ model.

```{r}
form_lambda = '(consumption^lambda - 1)/lambda ~ cylinders + displacement + horsepower + weight + 
acceleration + model_year + origin + cylinders:horsepower + 
cylinders:model_year + displacement:horsepower + displacement:acceleration + 
displacement:model_year + displacement:origin + horsepower:weight + 
horsepower:model_year + weight:acceleration + weight:model_year + 
weight:origin + acceleration:model_year + acceleration:origin'

lm_final_bc = lm(form_lambda,data_mpghp)
summary(lm_final_bc)

```


A validujeme tento model.

```{r}
par(mfrow=c(1,2))

plot(lm_final_bc,which=2)
plot(lm_final_bc,which=1)

```

Oba ploty vypadajĂ­ hezky, podĂ­vĂˇme se jeĹˇtÄ› na normalitu pomocĂ­ Shapirova testu.

```{r}
shapiro.test(residuals(lm_final_bc))

```
Normalita krĂˇsnÄ› prochĂˇzĂ­.
Vzhledemk téměř nulové hodnotě lambda bych se nakonec rozhodl pro model s log-transformovanou spotřebou. OLS požadavky prochází u obou modelů a box-coxovým modelem bychom si téměř znemožnily interpretabilitu. Navíc pro lambda blízké k 0 se tato transformace blíží k logaritmické.



## OtĂˇzka ÄŤ.18: Pro model s log-transformovanou spotĹ™ebou v bodÄ› 16 vypoÄŤtÄ›te procentuĂˇlnĂ­ navĂ˝ĹˇenĂ­/pokles spotĹ™eby automobilu pĹ™i zmÄ›nÄ› vĂˇhy o 1000kg. Porovnejte, jak se zmÄ›nil vliv spotĹ™eby na vĂˇze s porovnĂˇnĂ­m s modelem z bodu 8.

Opět se zde bude jednat o procentuální/multiplikativní vztah mezi jednotlivými odezvami. Jelikož ještě model nemáme ošetřený vzhledem ke kolinearitě, tuto otázku zodpovím až u finálního modelu.


## OtĂˇzka ÄŤ.19: SpoÄŤtÄ›te korelace mezi vĹˇemi dostupnĂ˝mi promÄ›nnĂ˝mi, kde to dĂˇvĂˇ smysl a u korelovanĂ˝ch promÄ›nnĂ˝ch se pokuste zdĹŻvodnit dĹŻvod tĂ©to korelace. Zkoumejte pĹ™Ă­padnou multikolinearitu ve vaĹˇem finĂˇlnĂ­m modelu z bodu 16 a pomocĂ­ podmĂ­nÄ›nĂ© matice regresorĹŻ, VIF a dalĹˇĂ­ch nĂˇstrojĹŻ validujte vĂˇĹˇ vĂ˝bÄ›r.

Na zaÄŤĂˇtek zkoumĂˇnĂ­ kolinearity vyzkouĹˇĂ­me vyzkouĹˇĂ­me kompletnĂ­ aditivnĂ­ model bez pomocnĂ˝ch promÄ›nnĂ˝ch, car_name a producer a nechĂˇme si vypsat VIF hodnoty kvĹŻli detekci kolinearity.

```{r}
lmm <- lm(consumption ~ (.)-car_name-producer-constant_weight-constant_weight2-mpg,data_mpghp)

```

```{r}
kappa(lmm)
vif(lmm)
```

VidĂ­me, Ĺľe vyĹˇĹˇĂ­ hodnoty VIF jsou u numerickĂ˝ch promÄ›nnĂ˝ch cylinders,displacement,horsepowera weight, kterĂ© by mohly bĂ˝t mezi sebou korelovanĂ© To jde ostatnÄ› vidÄ›t i ze scatterplotĹŻ v prvnĂ­ ÄŤĂˇsti protokolu. PodĂ­vĂˇme se na vĂ˝stup z ggpairs pro tyto promÄ›nnĂ©.

```{r}
library(GGally)
ggpairs(data_mpghp[c("cylinders","displacement","horsepower","weight")])
```

Mezi tÄ›mito promÄ›nnĂ˝mi je zĹ™ejmĂˇ kolinearita.
Z grafĹŻ jde vidÄ›t, Ĺľe pokud jedna z promÄ›nnĂ˝ch "roste", pak "roste" i druhĂˇ, coĹľ v podstatÄ›
sedĂ­ i s fyzikĂˇlnĂ­m cĂ­tÄ›nĂ­m Ăşlohy, kde se zdĂˇ, Ĺľe se zvyĹˇujĂ­cĂ­ se vĂˇhou vozidla musĂ­ rĹŻst i spotĹ™eba. TotĂ©Ĺľ, pokud zvyĹˇujeme poÄŤet vĂˇlcĹŻ, zdvihovĂ˝ objem ÄŤĂ­ vĂ˝kon, pak se takĂ© zvyĹˇuje spotĹ™eba.

Z tÄ›chto promÄ›nnĂ˝ch bude tedy staÄŤit uvaĹľovat pouze jednu. KterĂˇ to bude zjistĂ­me postupnĂ˝m "vyhazovĂˇnĂ­m" promÄ›nnĂ˝ch s nejvyĹˇĹˇĂ­ VIF hodnotou. TĂ­mto zpĹŻsobem nakonec zĹŻstane weight.


```{r}
lmm1 <- lm(consumption ~ (.)-car_name-producer-displacement-horsepower-cylinders-constant_weight-constant_weight2-mpg,data_mpghp)
kappa(lmm1)
vif(lmm1)
```
PodaĹ™ilo se nĂˇm snĂ­Ĺľit ÄŤĂ­slo podmĂ­nÄ›nosti kappa a takĂ© vidĂ­me, Ĺľe VIF hodnoty u zbĂ˝vajĂ­cĂ­ch promÄ›nnĂ˝ch jsou dostateÄŤnÄ› nĂ­zkĂ©, takĹľe se nĂˇm kolinearitu podaĹ™ilo tĂ­mto zpĹŻsobem vĂ˝znamnÄ› snĂ­Ĺľit.

NynĂ­ se zamÄ›Ĺ™Ă­me na multikolinearitu v naĹˇem finĂˇnĂ­m modelu z otĂˇzky 16. VypĂ­Ĺˇeme si ÄŤĂ­slo podmĂ­nÄ›nosti matice regresorĹŻ kappa a VIF hodnoty v modelu.


```{r}
kappa(lm_final_log)
vif(lm_final_log)
```

VĹˇechny hodnoty jsou velmi vysokĂ©, multikolinearita v modelu je jasnĂˇ a musĂ­me ji co nejvĂ­ce snĂ­Ĺľit. PĹŻjdeme na to tĂ­mto zpĹŻsobem: iterativnÄ› budeme odebĂ­rat promÄ›nnĂ© s nejvyĹˇĹˇĂ­ VIF hodnotou. NÄ›kdy se stalo, Ĺľe se VIF hodnoty pro vĂ­ce promÄ›nnĂ˝ch liĹˇily napĹ™. na 3 desetinnĂ©m mĂ­ste -> zkusil jsem vĂ­ce moĹľnostĂ­ zahazovĂˇnĂ­ a vĂ˝slednĂ© modely porovnal pomocĂ­ anova()
threshold VIF hodnoty pro odebrĂˇnĂ­ promÄ›nnĂ© jsem nastavil na 3, ale v pozdÄ›jĹˇĂ­ch fĂˇzĂ­ch vyhazovĂˇnĂ­ se obÄŤas stalo, Ĺľe jedna VIF hodnota byla nĂˇpadnÄ› vysokĂˇ proti ostatnĂ­m a blĂ­zko 3 (2,8...), tak to jsem takĂ© zahodil. CelĂ˝ postup byl velmi zdlouhavĂ˝. Uvedu finĂˇlnĂ­ model, kterĂ˝ z tĂ©to procedury vyĹˇel nejlĂ©pe.

```{r}
form = "log(consumption) ~ cylinders+ origin + acceleration+
horsepower:model_year + weight:acceleration"
lm_final = lm(form,data_mpghp)
vif(lm_final)
kappa(lm_final)

```

VidĂ­me, Ĺľe kolinearitu v modelu se nĂˇm podaĹ™ilo velmi vĂ˝raznÄ› snĂ­Ĺľit. PodĂ­vĂˇme se na model pomocĂ­ summary funkce.

```{r}
summary(lm_final)
```

ZkusĂ­me tento model jeĹˇtÄ› validovat. PodĂ­vĂˇme se na diagnostickĂ© ploty.

```{r}
par(mfrow=c(2,2))
plot(lm_final,which=1)
plot(lm_final,which=2)
plot(lm_final,which=3)


```

Ploty vypadajĂ­ hezky, i kdyĹľ homoskedasticita reziduĂ­ v residuals vs fitted plotu je mĂ­rnÄ› podezĹ™elĂˇ.

```{r}
shapiro.test(residuals(lm_final))
```

ShapirĹŻv test nezamĂ­tĂˇ normalitu.
```{r}
bptest(lm_final)
```
Bptest tÄ›snÄ› zamĂ­tĂˇ homoskedasticitu.

## OtĂˇzka ÄŤ.20: Vykreslete tzv. partial regression plot a tzv. partial residual plot pro finĂˇlnĂ­ model. Okomentujte, co nĂˇm zmĂ­nÄ›nĂ© grafy Ĺ™Ă­kajĂ­ o vĂ˝slednĂ©m modelu.

Tyto grafy znĂˇzorĹujĂ­ vliv jednĂ© nezĂˇvislĂ© promÄ›nnĂ© na response variable pĹ™i uvĂˇĹľenĂ­ vlivu ostatnĂ­ch promÄ›nnĂ˝ch v modelu. Partial regression plot se hodĂ­ na detekci influenÄŤnĂ­ch bodĹŻ,
navĂ­c sklon regresnĂ­ pĹ™Ă­mky v tÄ›chto plotech je stejnĂ˝ jako sklon danĂ© promÄ›nnĂ© v pĹŻvodnĂ­m vĂ­cerozmÄ›rnĂ©m lineĂˇrnĂ­m modelu. Naproti tomu partial residual plot je vhodnĂ˝ k detekci nelinearity mezi danou promÄ›nnou, mĹŻĹľe nĂˇm odhalit vhodnĂ© transformace nezĂˇvislĂ˝ch promÄ›nnĂ˝ch k zajiĹˇtÄ›nĂ­ ÄŤi zlepĹˇenĂ­ linearity.

Jako prvnĂ­ vykreslĂ­me partial regression ploty.

```{r}
library(car)
avPlots(lm_final)

```

VidĂ­me, Ĺľe nÄ›kolik bodĹŻ bylo znĂˇzornÄ›no jako podezĹ™elĂ© influenÄŤnĂ­ body, budeme se jimi zabĂ˝vat v dalĹˇĂ­ch otĂˇzkĂˇch.

Residual plot pomocĂ­ podobnĂ©ho balĂ­ÄŤku vykreslit nemĹŻĹľeme (nechce vykreslit pro model s interakcemi). VykreslĂ­me si interakce a faktorovĂ© promÄ›nnĂ© alespoĹ pomocĂ­ balĂ­ÄŤku effects, i kdyĹľ to nenĂ­ pĹ™esnÄ› to, co hledĂˇme.

```{r}
library(effects)
plot(Effect(c("horsepower","model_year"), lm_final, partial.residuals = TRUE), nrow = 1)
plot(Effect(c("acceleration","weight"), lm_final, partial.residuals = TRUE), nrow = 1)
plot(Effect(c("origin"), lm_final, partial.residuals = TRUE), nrow = 1)

```
VidĂ­me, Ĺľe origin by se teoreticky jako promÄ›nnĂˇ dala vynechat, jelikoĹľ stĹ™ednĂ­ hodnoty log(consumption) se pro jednotlivĂ© faktory tĂ©mÄ›r rovnajĂ­ a jednotlivĂ© klastry pro kaĹľdĂ˝ faktor majĂ­ i pĹ™ibliĹľnÄ› stejnĂ˝ rozptyl. Zkusil jsem udÄ›lat tuto Ăşpravu a origin z finĂˇlnĂ­ho modelu odstranit. Tahle Ăşprava ale vedla k poruĹˇenĂ­ podmĂ­nky normality reziduĂ­, proto jsem se tĂ­m dĂˇl nezabĂ˝val.

Pro acceleration a cylinders vykreslĂ­me partial residual ploty ruÄŤnÄ›.


```{r}
coef_acceleration <- lm_final$coefficients['acceleration']
Y = residuals(lm_final) + coef_acceleration*data_mpghp[,'acceleration']
X = data_mpghp[,'acceleration']
plot(X,Y,main = 'Partial residual plot acceleration')
gamLine(x=X,y=Y) # smooth kĹ™ivka
abline(lm(Y~X),col='red',lwd=2)

```


```{r}
coef_cylinders <- lm_final$coefficients['cylinders']
Y = residuals(lm_final) + coef_cylinders*data_mpghp[,'cylinders']
X = data_mpghp[,'cylinders']
plot(X,Y,main='Partial residual plot cylinders')
quantregLine(x=X,y=Y)
abline(lm(Y~X),col='red',lwd=2)

```


Pro acceleration i cylinders vypadĂˇ linearita dobĹ™e. Z toho plyne, Ĺľe nenĂ­ potĹ™eba aplikovat nÄ›jakĂ© transformace vysvÄ›tlujĂ­cĂ­ch promÄ›nnĂ˝ch.

## OtĂˇzka ÄŤ.21: Prezentujte vĂˇĹˇ vĂ˝slednĂ˝ model pro predikci consumption, diskutujte vĂ˝slednĂ© parametry R^2 a sigma tohoto modelu. Pokud jste model nevalidovali v pĹ™edchozĂ­ch krocĂ­ch, tak ho validujte (jak graficky, tak pomocĂ­ pĹ™Ă­sluĹˇnĂ˝ch testĹŻ hypotĂ©z).

VĂ˝slednĂ˝ model pro predikci je
```{r}
summary(lm_final)

```
Pokud se vrátím k otázce č.18, tak v modelu se vyskytuje weight pouze ve formě interakce s acceleration. Zde není zřejmé, jak se změní acceleration:weight při změně váhy o 1000kg, takže v případě tohoto modelu nelze přesně odpovědět, závisí to na hodnotě acceleration.


Model byl v pĹ™edchozĂ­ch krocĂ­ch validovĂˇn, normalita reziduĂ­ je v poĹ™Ăˇdku, homoskedasticita vypadĂˇ z diagnostickĂ˝ch grafĹŻ dobĹ™e, i kdyĹľ residual vs fitted plot obsahuje minimĂˇlnĂ­ nĂˇznak nÄ›jakĂ©ho "pevnĂ©ho" vzoru, coĹľ by mohlo indikovat lehkou heteroskedasticitu. 
Hodnota R^2 statistiky je 0.8899 (adjusted R^2 je 0.8846), coĹľ je povaĹľovĂˇno za velmi dobrou hodnotu. Hodnota sigma modelu je pĹ™ibliĹľnÄ› 0.114637.
```{r}
sigma(lm_final)
```

## OtĂˇzka ÄŤ.22: Obsahuje VĂˇĹˇ model z bodu 19 nÄ›jakĂˇ vlivnĂˇ pozorovĂˇnĂ­? Pokuste se detekovat odlehlĂ© a pĂˇkovĂ© body pomocĂ­ rĹŻznĂ˝ch diagnostickĂ˝ch nĂˇstrojĹŻ tzv. leave-one-out deletion regression.

PodivĂˇme se na cook distance a residuals vs leverage
```{r}
par(mfrow=c(1,2))
plot(lm_final, which = 4)
plot(lm_final, which = 5)
```

VlivnĂˇ pozorovĂˇnĂ­ jsou v plotech vyznaÄŤena 124,174 a 342.

VypĂ­Ĺˇeme influence.measures (leave one out regression) a podĂ­vĂˇme se na podezĹ™elĂ© influenÄŤnĂ­ body a jejich vliv na rĹŻznĂ© uvaĹľovanĂ© metriky (dffit,..).

```{r}
summary(influence.measures(lm_final))

```

Z tabulky mĹŻĹľeme vypozorovat, Ĺľe vĹˇechny podezĹ™elĂ© body ovlivĹujĂ­ pĹ™edevĹˇĂ­m covariance ratio
a hlavnĂ­ podezĹ™elĂ© body z regression vs leverage plotu takĂ© kvalitu fitu (dffits kritĂ©rium)

Vzhledem k tabulce se jako nejvĂ­ce podezĹ™elĂ© body jevĂ­ 124,174,342 , kterĂ© majĂ­ takĂ© nejvÄ›tĹˇĂ­ cook distance. Tato 3 pozorovĂˇnĂ­ jsou adepty na odstranÄ›nĂ­.

## OtĂˇzka ÄŤ.23: Pokud jste odhalili nÄ›jakĂˇ vlivnĂˇ pozorovĂˇnĂ­, jak byste s nimi naloĹľili a proÄŤ?

NaĹˇli jsme nÄ›kolik influenÄŤnĂ­ch bodĹŻ vzhledem k leave one out regression. Po prozkoumĂˇnĂ­ a srovnĂˇnĂ­ podezĹ™elĂ˝ch hodnot s ostatnĂ­mi (napĹ™. s podobnou vahou, vĂ˝konem,...) jsem se nakonec rozhodl data z finĂˇlnĂ­ho modelu neodstraĹovat ani nemodifikovat, protoĹľe se nezdĂˇ, Ĺľe by tato pozorovĂˇnĂ­ byla ovlivnÄ›na nÄ›jakou systematickou chybou ÄŤi by se aĹľ pĹ™Ă­liĹˇ nepravdÄ›podobnÄ› odchylovala od ostatnĂ­ch zĂˇznamĹŻ.

## OtĂˇzka ÄŤ.24: Porovnejte regresnĂ­ koeficienty, kterĂ© jste obdrĹľeli z vĂ˝slednĂ©ho klasickĂ©ho lineĂˇrnĂ­ho modelu (s a bez odhledlĂ˝ch pozorovĂˇnĂ­) s robustnĂ­mi modely. VyzkouĹˇejte MM odhad (pro dva druhy funkce psi) a LTS odhad pĹ™i pouĹľitĂ­ (90% a 50% pozorovĂˇnĂ­).


PrvnĂ­ nastavĂ­me novĂ˝ dataset bez hlavnĂ­ch influenÄŤnĂ­ch bodĹŻ (124,174,342).

```{r}
data_noinfluential = data_mpghp[!(rownames(data_mpghp) %in% c("124","174","342")),]
```

FinĂˇlnĂ­ klasickĂ˝ model jsme jiĹľ v druhĂ© ÄŤĂˇsti protokolu vybrali model s logaritmicky ĹˇkĂˇlovanou spotĹ™ebou umocnÄ›nou na druhou.

```{r}
lm_logsquared_noinf = lm(log(consumption)^2 ~ weight,data_noinfluential)
```

NachystĂˇme robustnĂ­ modely. V MM modelech pouĹľijeme jako psi ggw a bisquare.

```{r}
library(robustbase)
library(rrcov)    
library(robust)
MM_bisquare_stars<- rlm(log(consumption)^2 ~ weight, method="MM",psi = psi.bisquare, data = data_mpghp)
MM_ggw   <- rlm(log(consumption)^2 ~ weight, method="MM",psi = psi.ggw, data= data_mpghp)

```


A LTS s 50% a 90% pozorovĂˇnĂ­.
```{r}
LTS_50  <- ltsReg(log(consumption)^2 ~ weight, alpha=0.5, data = data_mpghp)
LTS_90  <- ltsReg(log(consumption)^2 ~ weight, alpha=0.9, data = data_mpghp)
```

NynĂ­ vykreslĂ­me scatter plot a regresnĂ­ pĹ™Ă­mky vĹˇech modelĹŻ.

```{r}
p <- ggplot(data, aes(x=weight, y=log(consumption)^2)) + geom_point()+
  geom_line(aes(x=weight,y=lm_logcons_squared$fitted.values,color = 'red'))+
  geom_line(data = data_noinfluential,aes(x=weight,y=lm_logsquared_noinf$fitted.values,color='blue'))+
  geom_line(aes(x=weight,y=MM_bisquare_stars$fitted.values,color='yellow')) +
  geom_line(aes(x=weight,y=MM_ggw$fitted.values,color='orange')) +
  geom_line(aes(x=weight,y=LTS_50$fitted.values,color='green')) +
  geom_line(aes(x=weight,y=LTS_90$fitted.values,color='brown')) +
  scale_color_discrete(name = 'methods',labels = c('classic','no influential points','MM_bisquare','MM_ggw','LTS 50%','LTS 90%'))
plot(p)
```


RegresnĂ­ pĹ™Ă­mky jsou v podstatÄ› identickĂ©. Pokud by existovaly opravdu silnĂ© influenÄŤnĂ­ body, kterĂ© by odchylovaly pĹ™Ă­mku z klasickĂ©ho modelu, pak by se klasickĂ˝ model a robustnĂ­ modely vĂ­ce liĹˇily.

## OtĂˇzka ÄŤ.25: Diskutujte, jak by Ĺˇlo pĹ™Ă­padnÄ› zlepĹˇit predikci, jakĂ© transformace jednotlivĂ˝ch promÄ›nnĂ˝ch by mohli pomoci. PĹ™evedli byste nÄ›kterĂ© dalĹˇĂ­ spojitĂ© promÄ›nnĂ© na diskrĂ©tnĂ­ (na faktory)? JakĂ© dalĹˇĂ­ kroky byste pĹ™i analĂ˝ze navrhli?

Pokud se podĂ­vĂˇme na signifikanci jednotlivĂ˝ch promÄ›nnĂ˝ch, vidĂ­me, Ĺľe horsepower:model_year79 aĹľ horsepower:model_year 82 jsou mĂ©nÄ› signifikantnĂ­ neĹľ ostatnĂ­, navĂ­c jsme v pĹ™edchozĂ­ch otĂˇzkĂˇch zjistili (z grafĹŻ), Ĺľe by se promÄ›nnĂˇ model_year dala slouÄŤit na mĂ©nÄ› faktorĹŻ. V tomto pĹ™Ă­padÄ› by moĹľnĂˇ mohlo pomoci nechat vĹˇechny faktory aĹľ na 80-82, kterĂ© bychom slouÄŤily dohromady. Rok 79 bych tam jiĹľ nepĹ™idĂˇval, hodnoty consumption pro tento faktor (a tedy stĹ™ednĂ­ hodnota) se od 80-82 znaÄŤnÄ› liĹˇĂ­, viz obrĂˇzek.

```{r}

p1 <- ggplot(data_mpghp,aes(x=model_year,y=consumption, fill = model_year)) + 
  geom_boxplot(notch=FALSE,outlier.color = 'black') + scale_fill_discrete(name='year')
plot(p1)


```

Co se tĂ˝ÄŤe transformacĂ­ nezĂˇvislĂ˝ch promÄ›nnĂ˝ch, tak z partial residual plotu jsme nezaznamenali nÄ›jakĂ© podezĹ™elĂ© nelineĂˇrnĂ­ chovĂˇnĂ­, tĂ­m pĂˇdem bych transformace nevyuĹľĂ­val.
Pokud se podĂ­vĂˇme jeĹˇtÄ› jednou na kolinearitu v modelu
```{r}

vif(lm_final)

```

VidĂ­me, Ĺľe acceleration by mohlo bĂ˝t korelovanĂ© s acceleration:weight. ZkusĂ­me proto acceleration odstranit (mĂˇ vyĹˇĹˇĂ­ VIF neĹľ acceleration:weight).

```{r}

lm_no_acceleration = lm(log(consumption)~cylinders + origin+horsepower:model_year+acceleration:weight,data_mpghp)
summary(lm_no_acceleration)

```
Dostali jsme model, kde je o nÄ›co niĹľĹˇĂ­ kolinearita neĹľ v pĹŻvodnĂ­m modelu a vĹˇechny pouĹľitĂ© nezĂˇvislĂ© promÄ›nnĂ© jsou znaÄŤnÄ› signifikantnĂ­. PorovnĂˇme pomocĂ­ anova() tento model s pĹŻvodnĂ­m.

```{r}

anova(lm_no_acceleration,lm_final)

```

VidĂ­me, Ĺľe anova preferuje vĂ­ce pĹŻvodnĂ­ model.
```{r}

shapiro.test(residuals(lm_no_acceleration))

```
NavĂ­c vidĂ­me, Ĺľe ShapirĹŻv test zamĂ­tĂˇ normalitu, tudĂ­Ĺľ tento model nesplĹuje OLS pĹ™edpoklady.

## OtĂˇzka ÄŤ.26: PĹ™edstavte si, Ĺľe mĂˇte flotilu aut sloĹľenou z dostupnĂ˝ch dat. Bez ohledu na nosnost auta (pĹ™edpoklĂˇdejme, Ĺľe to zvlĂˇdnou vĹˇechny) potĹ™ebujete pĹ™evĂ©st pro znĂˇmĂ©ho z Brna hl. nĂˇdraĹľĂ­ do Prahy do Trojanovy 13, 800kg nĂˇkladu. JakĂ© auto si vyberete a proÄŤ? O kolik se vĂˇm cesta prodraĹľĂ­ a tudĂ­Ĺľ by vĂˇm mÄ›l kamarĂˇd zaplatit (neuvaĹľujte amortizaci auta a vezmÄ›te cenu 30kÄŤ za palivo).

Je zĹ™ejmĂ©, Ĺľe nemĹŻĹľeme jen tak pĹ™edpoklĂˇdat pro libovolnĂ© auto, Ĺľe pokud na nÄ›j naloĹľĂ­me nÄ›jakou zĂˇtÄ›Ĺľ, tak se jeho spotĹ™eba bude chovat lineĂˇrnÄ› podle nĂˇmi nalezenĂ©ho modelu. MusĂ­me na to jĂ­t jinak.

MĹŻj postup by byl takovĂ˝to:

1. vyrobĂ­me jednoduchĂ˝ klasickĂ˝ model (lm(consumption ~ weight - 1)- pouĹľijeme model bez interceptu
2. vytvoĹ™Ă­me podobnĂ© skupiny aut vzhledem k nÄ›kolika nezĂˇvislĂ˝m promÄ›nnĂ˝m urÄŤujĂ­cĂ­m spotĹ™ebu (napĹ™. pomocĂ­ K-Means algoritmu, urÄŤitÄ› by to Ĺˇlo udÄ›lat i dĹŻkladnÄ›ji a jinak)
, za tyto promÄ›nnĂ© zvolĂ­me cylinders,horsepower,acceleration,displacement (zajĂ­majĂ­ mÄ› pĹ™edevĹˇĂ­m klastry na zĂˇkladÄ› technickĂ˝ch parametrĹŻ aut, proto origin ani model_year uvaĹľovat nebudeme)
3. jako poslednĂ­ krok se podĂ­vĂˇme na rezidua u jednotlivĂ˝ch skupin a zjistĂ­me, jak moc pĹ™esnÄ› tyto skupiny opisujĂ­ regresnĂ­ pĹ™Ă­mku danou modelem a vezmeme tu skupinu, kterĂˇ bude mĂ­t nejmenĹˇĂ­ rezidua (suma reziduĂ­^2 normovanĂˇ poÄŤtem ÄŤlenĹŻ ve skupinÄ›) a vizuĂˇlnÄ› bude opisovat nejlĂ©pe regresnĂ­ pĹ™Ă­mku. U takovĂ˝ch skupin lze oÄŤekĂˇvat velmi podobnĂ© hodnoty v ostatnĂ­ch promÄ›nnĂ˝ch (cylinders,horsepower,acceleration,displacement) a tedy mĹŻĹľeme pĹ™edpoklĂˇdat, Ĺľe u aut s takovĂ˝mi technickĂ˝mi parametry se zĂˇvislost spotĹ™eby na vĂˇze automobilu chovĂˇ "pĹ™ibliĹľnÄ›" lineĂˇrnÄ› - hrubÄ› si to pĹ™edstavuji tak, Ĺľe zafixujeme ostatnĂ­ promÄ›nnĂ© kromÄ› weight a sleduju zmÄ›nu spotĹ™eby jen na zĂˇkladÄ› pĹ™idĂˇvĂˇnĂ­ vĂˇhy. Nakonec vybereme jedno auto z tĂ©to skupiny dle uvĂˇĹľenĂ­. MÄ›li bychom vybrat nejlepĹˇĂ­ho reprezentanta danĂ© skupiny (vektor nejblĂ­Ĺľe ke stĹ™edu klastru), pokud bude takovĂ˝ch aut vĂ­ce, pak vezmeme to nejlehÄŤĂ­, protoĹľe pak mĂˇme vÄ›tĹˇĂ­ jistotu, Ĺľe pĹ™idĂˇnĂ­m nejvÄ›tĹˇĂ­ vĂˇhy se spotĹ™eba zmÄ›nĂ­ lineĂˇrnÄ› (pokud v tĂ©to skupinÄ› mĂˇme nejlehÄŤĂ­ auto vĂˇĹľĂ­cĂ­ 1000kg a nejtÄ›ĹľĹˇĂ­ 1500kg, pak u 1000kg auta naloĹľenĂ­m 500kg jeĹˇtÄ› stĂˇle mĹŻĹľu pĹ™edpoklĂˇdat lineĂˇrnĂ­ zĂˇvislost spotĹ™eby).

RozdÄ›lĂ­me do 20 klastrĹŻ pomocĂ­ KMeans a nastavĂ­me model

```{r}
data_temp = data_mpghp[,c('cylinders','displacement','horsepower','acceleration')]
# naklastrujeme
set.seed(2)
clusters <- kmeans(data_temp, centers =  20, iter.max = 100)
data_mpghp$clusters = clusters$cluster
lm_classic <- lm(consumption ~ weight - 1, data_mpghp)
```

Jako prvnĂ­ si vykreslĂ­me regresnĂ­ pĹ™Ă­mky a scatterploty vĹˇech 20 skupin, vizuĂˇlnÄ› jsem zĂşĹľil vĂ˝bÄ›r na 3 adepty, kterĂ© dobĹ™e opisujĂ­ regresnĂ­ pĹ™Ă­mku a ve kterĂ˝ch se vyskytujĂ­ auta s dostateÄŤnĂ˝m vĂˇhovĂ˝m rozdĂ­lem (potĹ™ebujeme linearitu pĹ™i naloĹľenĂ­ 800kg, takĹľe pokud jsou auta ve skupinÄ› s pĹ™ibliĹľnÄ› stejnou hmotnostĂ­, moc nĂˇm to nepomĹŻĹľe), grafy zde znĂˇzornĂ­m

adepti: cluster 2,4,11

```{r}

p1 <- ggplot(data_mpghp[data_mpghp[,'clusters']==2,], aes(weight, consumption))+geom_point()+
  geom_line(data = data_mpghp, aes(x=weight,y=lm_classic$fitted.values), size = 0.8)

p2 <- ggplot(data_mpghp[data_mpghp[,'clusters']==4,], aes(weight, consumption))+geom_point()+
  geom_line(data = data_mpghp, aes(x=weight,y=lm_classic$fitted.values), size = 0.8)

p3 <- ggplot(data_mpghp[data_mpghp[,'clusters']==11,], aes(weight, consumption))+geom_point()+
  geom_line(data = data_mpghp, aes(x=weight,y=lm_classic$fitted.values), size = 0.8)

figure <- ggarrange(p1, p2, p3,
                    labels = c("klastr 2", "klastr 4", "klastr 11"),
                    ncol = 2, nrow = 2)
plot(figure)

```



NynĂ­ spoÄŤĂ­tĂˇme a porovnĂˇme sumu normovanĂ˝ch reziduĂ­^2 pro tyto skupiny.


```{r}

res_2 = (lm_classic$residuals[data_mpghp[,'clusters']==2])^2
sum_res_2 = (1/length(res_2))*sum(res_2)
sum_res_2

res_4 = (lm_classic$residuals[data_mpghp[,'clusters']==4])^2
sum_res_4 = (1/length(res_4))*sum(res_4)
sum_res_4

res_11 = (lm_classic$residuals[data_mpghp[,'clusters']==11])^2
sum_res_11 = (1/length(res_11))*sum(res_11)
sum_res_11


```

NejlĂ©pe vychĂˇzĂ­ klastr ÄŤĂ­slo 11. Jako nejlepĹˇĂ­ho reprezentanta tĂ©to skupiny vezmeme bod nejblĂ­Ĺľe stĹ™edu klastru, tj. bod nejblĂ­Ĺľe k (vzhledem k euklidovskĂ© metrice)

```{r}

center = clusters$centers[11,]
center
```

NejbliĹľĹˇĂ­ bod z tĂ©to skupiny je Toyota Cressida z roku 81 vĂˇĹľĂ­cĂ­ pĹ™ibliĹľnÄ› 1315kg. Volil bych tedy toto auto. Jako alternativu by jeĹˇtÄ› mohl bĂ˝t druhĂ˝ nejbliĹľĹˇĂ­ bod, kterĂ˝m je auto Oldsmobile Omega Brougham z roku 79, kterĂ© vĂˇĹľĂ­ o nÄ›co mĂ©nÄ›, a to pĹ™ibliĹľnÄ› 1225kg.

Vzhledem k pĹ™edchozĂ­ Ăşvaze by se u tÄ›chto aut s velmi podobnĂ˝mi technickĂ˝mi parametry mÄ›la spotĹ™eba na zvyĹˇujĂ­cĂ­ se (pouze) hmotnosti mÄ›nit pĹ™ibliĹľnÄ› lineĂˇrnÄ›.

KamarĂˇd by tedy za pĹ™evoz 800kg nĂˇkladu zaplatil 
(koeficient weight v lin. modelu)* (800kg) *(vzdĂˇlenost Brno hl.n. - Praha Trojanova 13 v jednotkĂˇch 100km)*30 =
```{r}
0.0083554*800*2.05*30
```
Tedy pĹ™ibliĹľnÄ› 411 KÄŤ.











